from Standard.Base import all

import Database_Tests.Helpers.Fake_Test_Connection
import Standard.Database.Data.Dialect
import Standard.Test

from Standard.Database import all
from Standard.Database.Data.Sql import Sql_Type
from Standard.Table import No_Such_Column_Error, Order_Rule

spec =
    int = Sql_Type.integer
    bool = Sql_Type.boolean
    str = Sql_Type 424242
    test_connection =
        table1 = ["T1", [["A", int], ["B", str], ["C", bool]]]
        table2 = ["T2", [["D", int], ["E", int], ["F", bool]]]
        table3 = ["T3", [["A", int], ["E", bool], ["F", int]]]
        tables = Map.from_vector [table1, table2, table3]
        Fake_Test_Connection.make Dialect.sqlite tables
    t1 = test_connection.access_table "T1"
    Test.group "[Codegen] JSON serialization" <|
        Test.specify "should serialize Tables and Columns to their SQL representation" <|
            q1 = t1.where (t1.at "A" == 42) . to_json
            part1 = Json.from_pairs [["sql_code", 'SELECT "T1"."A" AS "A", "T1"."B" AS "B", "T1"."C" AS "C" FROM "T1" AS "T1" WHERE ("T1"."A" = ']]
            interp = Json.from_pairs [["value", 42], ["typeid", int.typeid]]
            part2 = Json.from_pairs [["sql_interpolation", interp]]
            part3 = Json.from_pairs [["sql_code", ")"]]
            expected = Json.from_pairs [["query", Json.Array [part1, part2, part3]]]
            q1.should_equal expected

            q2 = t1.at "A" . to_json
            q2.should_equal (Json.from_pairs [["query", Json.Array [Json.from_pairs [["sql_code", 'SELECT "T1"."A" AS "A" FROM "T1" AS "T1"']]]]])

    Test.group "[Codegen] Basic Select" <|
        Test.specify "should select columns from a table" <|
            t1.to_sql.prepare . should_equal ['SELECT "T1"."A" AS "A", "T1"."B" AS "B", "T1"."C" AS "C" FROM "T1" AS "T1"', []]
            t2 = t1.select ["C", "B", "undefined"]
            t2.to_sql.prepare . should_equal ['SELECT "T1"."C" AS "C", "T1"."B" AS "B" FROM "T1" AS "T1"', []]

            foo = t1.at "A" . rename "FOO"
            foo.to_sql.prepare . should_equal ['SELECT "T1"."A" AS "FOO" FROM "T1" AS "T1"', []]

            t3 = t2.set "bar" foo
            t3.to_sql.prepare . should_equal ['SELECT "T1"."C" AS "C", "T1"."B" AS "B", "T1"."A" AS "bar" FROM "T1" AS "T1"', []]

        Test.specify "should fail if at is called for a nonexisting column" <|
            t1.at "undefined" . should_fail_with No_Such_Column_Error

        Test.specify "should allow to limit the amount of returned results" <|
            t2 = t1.limit 5
            t2.to_sql.prepare . should_equal ['SELECT "T1"."A" AS "A", "T1"."B" AS "B", "T1"."C" AS "C" FROM "T1" AS "T1" LIMIT 5', []]

        Test.specify "should work correctly when there are no columns" <|
            empty = t1.select []
            json = Json.from_pairs [["query", Nothing], ["message", "The table has no columns so a query cannot be generated."]]
            empty.to_json . should_equal json
            empty.columns.length . should_equal 0
            empty.to_sql . should_fail_with Illegal_State_Error

    Test.group "[Codegen] Building Expressions" <|
        Test.specify "should allow building expressions from columns and constants" <|
            a = t1.at "A"
            b = t1.at "B"
            c = t1.at "C"
            arith = (a * 2) + 1
            logic = (c || c.not) && True
            cmp = (a / a >= b) && (a - b < a)
            arith.to_sql.prepare . should_equal ['SELECT (("T1"."A" * ?) + ?) AS "A" FROM "T1" AS "T1"', [[2, int], [1, int]]]
            logic.to_sql.prepare . should_equal ['SELECT (("T1"."C" OR (NOT "T1"."C")) AND ?) AS "C" FROM "T1" AS "T1"', [[True, bool]]]
            cmp.to_sql.prepare . should_equal ['SELECT ((("T1"."A" / "T1"."A") >= "T1"."B") AND (("T1"."A" - "T1"."B") < "T1"."A")) AS "A" FROM "T1" AS "T1"', []]

        Test.specify "should support simple text operations" <|
            b = t1.at "B"
            add = b + "SUFFIX"
            add.to_sql.prepare . should_equal ['SELECT ("T1"."B" + ?) AS "B" FROM "T1" AS "T1"', [["SUFFIX", str]]]

            ends = b.ends_with "suf"
            starts = b.starts_with "pref"
            contains = b.contains "inf"
            ends.to_sql.prepare . should_equal ['SELECT ("T1"."B" LIKE (\'%\' || ?)) AS "B" FROM "T1" AS "T1"', [["suf", str]]]
            starts.to_sql.prepare . should_equal ['SELECT ("T1"."B" LIKE (? || \'%\')) AS "B" FROM "T1" AS "T1"', [["pref", str]]]
            contains.to_sql.prepare . should_equal ['SELECT ("T1"."B" LIKE (\'%\' || ? || \'%\')) AS "B" FROM "T1" AS "T1"', [["inf", str]]]

    Test.group "[Codegen] Masking Tables and Columns" <|
        Test.specify "should allow filtering table rows based on a boolean expression" <|
            t2 = t1.where (t1.at "A" == 42)
            t2.to_sql.prepare . should_equal ['SELECT "T1"."A" AS "A", "T1"."B" AS "B", "T1"."C" AS "C" FROM "T1" AS "T1" WHERE ("T1"."A" = ?)', [[42, int]]]

        Test.specify "should allow selecting column rows based on a boolean expression" <|
            c2 = (t1.at "B").where (t1.at "A" == t1.at "C")
            c2.to_sql.prepare . should_equal ['SELECT "T1"."B" AS "B" FROM "T1" AS "T1" WHERE ("T1"."A" = "T1"."C")', []]

    Test.group "[Codegen] Joining Tables" <|
        t2 = test_connection.access_table "T2"
        t3 = test_connection.access_table "T3"
        Test.specify "should allow joining tables index-on-index" <|
            r1 = t1.set_index 'A' . join (t2.set_index 'D')
            r1.to_sql.prepare . should_equal ['SELECT "T1"."B" AS "B", "T1"."C" AS "C", "T2"."E" AS "E", "T2"."F" AS "F" FROM (SELECT "T1"."A" AS "A", "T1"."B" AS "B", "T1"."C" AS "C" FROM "T1" AS "T1") AS "T1" LEFT JOIN (SELECT "T2"."D" AS "D", "T2"."E" AS "E", "T2"."F" AS "F" FROM "T2" AS "T2") AS "T2" ON ("T1"."A" = "T2"."D")', []]

        Test.specify "should allow joining tables column-on-index" <|
            r1 = t1.join (t2.set_index 'D') on='B' drop_unmatched=True
            r1.to_sql.prepare . should_equal ['SELECT "T1"."A" AS "A", "T1"."B" AS "B", "T1"."C" AS "C", "T2"."E" AS "E", "T2"."F" AS "F" FROM (SELECT "T1"."A" AS "A", "T1"."B" AS "B", "T1"."C" AS "C" FROM "T1" AS "T1") AS "T1" INNER JOIN (SELECT "T2"."D" AS "D", "T2"."E" AS "E", "T2"."F" AS "F" FROM "T2" AS "T2") AS "T2" ON ("T1"."B" = "T2"."D")', []]

        Test.specify "should append suffixes to disambiguate column names" <|
            r1 = t1.join (t3.set_index 'E') on='A'
            r1.to_sql.prepare . should_equal ['SELECT "T1"."A" AS "A_left", "T1"."B" AS "B", "T1"."C" AS "C", "T3"."A" AS "A_right", "T3"."F" AS "F" FROM (SELECT "T1"."A" AS "A", "T1"."B" AS "B", "T1"."C" AS "C" FROM "T1" AS "T1") AS "T1" LEFT JOIN (SELECT "T3"."E" AS "E", "T3"."A" AS "A", "T3"."F" AS "F" FROM "T3" AS "T3") AS "T3" ON ("T1"."A" = "T3"."E")', []]

        Test.specify "should avoid duplicates when disambiguating column names" <|
            connection =
                table1 = ["T1", [["X", int], ["A", int], ["A_left", int]]]
                table2 = ["T2", [["X", int], ["A", int], ["B", int]]]
                tables = Map.from_vector [table1, table2]
                Fake_Test_Connection.make Dialect.sqlite tables
            t1 = connection.access_table "T1"
            t2 = connection.access_table "T2"
            (t1.set_index "X").join (t2.set_index "X") . should_fail_with Illegal_State_Error

        Test.specify "should ensure that name suffixes are distinct" <|
            err = (t1.set_index 'A').join (t2.set_index 'D') left_suffix='foo' right_suffix='foo'
            err . should_fail_with Illegal_State_Error

        Test.specify "should correctly handle self-joins" <|
            r1 = t1.join (t1.set_index 'A') on='B'
            r1.to_sql.prepare . should_equal ['SELECT "T1_left"."A" AS "A", "T1_left"."B" AS "B_left", "T1_left"."C" AS "C_left", "T1_right"."B" AS "B_right", "T1_right"."C" AS "C_right" FROM (SELECT "T1"."A" AS "A", "T1"."B" AS "B", "T1"."C" AS "C" FROM "T1" AS "T1") AS "T1_left" LEFT JOIN (SELECT "T1"."A" AS "A", "T1"."B" AS "B", "T1"."C" AS "C" FROM "T1" AS "T1") AS "T1_right" ON ("T1_left"."B" = "T1_right"."A")', []]

    Test.group "[Codegen] Handling Missing Values" <|
        Test.specify "fill_missing should allow to replace missing values in a column with a constant" <|
            c = t1.at "A" . fill_missing "not-applicable"
            c.to_sql.prepare . should_equal ['SELECT COALESCE("T1"."A", ?) AS "A" FROM "T1" AS "T1"', [["not-applicable", int]]]

        Test.specify "drop_missing should drop missing rows in a Column" <|
            col = t1.at "A" . drop_missing
            col.to_sql.prepare . should_equal ['SELECT "T1"."A" AS "A" FROM "T1" AS "T1" WHERE (NOT ("T1"."A" IS NULL))', []]

        Test.specify "drop_missing_rows should drop rows that contain at least one missing column in a Table" <|
            t2 = t1.drop_missing_rows
            t2.to_sql.prepare . should_equal ['SELECT "T1"."A" AS "A", "T1"."B" AS "B", "T1"."C" AS "C" FROM "T1" AS "T1" WHERE (NOT ("T1"."A" IS NULL)) AND (NOT ("T1"."B" IS NULL)) AND (NOT ("T1"."C" IS NULL))', []]

    Test.group "[Codegen] Aggregation" <|
        agg = t1.group by='A'

        Test.specify "should allow counting group sizes" <|
            agg.count.to_sql.prepare . should_equal ['SELECT COUNT(*) AS "count" FROM "T1" AS "T1" GROUP BY "T1"."A"', []]

        Test.specify "should allow aggregating columns with basic arithmetic aggregators" <|
            c1 = agg.at 'B' . mean
            c1.to_sql.prepare . should_equal ['SELECT AVG("T1"."B") AS "B_mean" FROM "T1" AS "T1" GROUP BY "T1"."A"', []]
            c2 = agg.at 'B' . min
            c2.to_sql.prepare . should_equal ['SELECT MIN("T1"."B") AS "B_min" FROM "T1" AS "T1" GROUP BY "T1"."A"', []]

        Test.specify "should allow grouping by multiple columns" <|
            agg = t1.group by=['A','B']
            agg.count.to_sql.prepare . should_equal ['SELECT COUNT(*) AS "count" FROM "T1" AS "T1" GROUP BY "T1"."A", "T1"."B"', []]

    Test.group "[Codegen] Sorting" <|
        Test.specify "should allow sorting by a single column name" <|
            r1 = t1.sort by="A" . at "B"
            r1.to_sql.prepare . should_equal ['SELECT "T1"."B" AS "B" FROM "T1" AS "T1" ORDER BY "T1"."A" ASC NULLS LAST', []]

            r2 = t1.sort by="B" missing_last=False order=Sort_Order.Descending . at "A"
            r2.to_sql.prepare . should_equal ['SELECT "T1"."A" AS "A" FROM "T1" AS "T1" ORDER BY "T1"."B" DESC NULLS FIRST', []]

        Test.specify 'should allow sorting by multiple column names' <|
            r1 = t1.sort by=['A', 'B']
            r1.to_sql.prepare . should_equal ['SELECT "T1"."A" AS "A", "T1"."B" AS "B", "T1"."C" AS "C" FROM "T1" AS "T1" ORDER BY "T1"."A" ASC NULLS LAST, "T1"."B" ASC NULLS LAST', []]

        Test.specify 'should allow sorting by expressions' <|
            sum = t1.at 'A' + t1.at 'B'
            r1 = t1.sort by=sum . at "C"
            r1.to_sql.prepare . should_equal ['SELECT "T1"."C" AS "C" FROM "T1" AS "T1" ORDER BY ("T1"."A" + "T1"."B") ASC NULLS LAST', []]

        Test.specify 'should allow sorting with specific by-column rules' <|
            r1 = t1.sort by=['A', (Order_Rule 'B' order=Sort_Order.Descending)]
            r1.to_sql.prepare . should_equal ['SELECT "T1"."A" AS "A", "T1"."B" AS "B", "T1"."C" AS "C" FROM "T1" AS "T1" ORDER BY "T1"."A" ASC NULLS LAST, "T1"."B" DESC NULLS LAST', []]

        Test.specify 'should return dataflow error when passed a non-existent column' <|
            r = t1.sort by='foobar'
            r.should_fail_with No_Such_Column_Error
